"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { addMonths } from "date-fns";
import { checkBudgetAndAlert } from "@/ai/flows/budgeting-alerts";
import { addDocumentNonBlocking, deleteDocumentNonBlocking, setDocumentNonBlocking } from '@/firebase/non-blocking-updates';
import { collection, getDocs, query, where, doc } from 'firebase/firestore';
import { getSdks } from "@/firebase";
import { initializeApp, getApps, getApp } from "firebase/app";
import { firebaseConfig } from "@/firebase/config";

// Function to get the Firestore instance on the server
function getserverFirestore() {
    const apps = getApps();
    const app = apps.length > 0 ? getApp() : initializeApp(firebaseConfig);
    const { firestore } = getSdks(app);
    return firestore;
}


async function getBudgetForCategory(userId: string, category: string): Promise<number> {
    const db = getserverFirestore();
    const budgetsCol = collection(db, `users/${userId}/budgets`);
    const q = query(budgetsCol, where("category", "==", category));
    const querySnapshot = await getDocs(q);
    if (!querySnapshot.empty) {
        // Assuming one budget per category for simplicity
        return querySnapshot.docs[0].data().limit;
    }
    return 0;
}

const transactionSchema = z.object({
  description: z.string().min(1, "Descrição é obrigatória."),
  value: z.number().min(0.01, "Valor deve ser maior que zero."),
  date: z.date(),
  account: z.string().min(1, "Conta é obrigatória."),
  category: z.string().min(1, "Categoria é obrigatória."),
  type: z.enum(["income", "expense"]),
  installments: z.number().min(1).max(120).default(1),
});

export type TransactionFormState = {
  message: string;
  errors?: {
    [key: string]: string[] | undefined;
  };
};

export async function addTransaction(
  userId: string,
  prevState: TransactionFormState,
  formData: FormData
): Promise<TransactionFormState> {

  if (!userId) {
    return {
        message: "Usuário não autenticado.",
        errors: { auth: ["Usuário não autenticado"] }
    }
  }
  const rawData = {
    description: formData.get("description"),
    value: Number(String(formData.get("value")).replace(",", ".")),
    date: new Date(formData.get("date") as string),
    account: formData.get("account"),
    category: formData.get("category"),
    type: formData.get("type"),
    installments: Number(formData.get("installments") || 1),
  };
  
  const validatedFields = transactionSchema.safeParse(rawData);
  
  if (!validatedFields.success) {
    console.error(validatedFields.error.flatten().fieldErrors);
    return {
      message: "Erro de validação. Verifique os campos.",
      errors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { data } = validatedFields;
  const groupId = data.installments > 1 ? crypto.randomUUID() : undefined;
  const db = getserverFirestore();
  const transactionsCol = collection(db, `users/${userId}/transactions`);

  for (let i = 0; i < data.installments; i++) {
    const transactionDate = addMonths(data.date, i);
    const transactionValue = data.type === 'expense' ? -data.value : data.value;

    const newTransaction = {
      // id will be auto-generated by Firestore
      userId,
      description: data.description,
      value: transactionValue,
      date: transactionDate.toISOString(),
      account: data.account,
      category: data.category,
      type: data.type,
      groupId,
      installments: data.installments > 1 ? { current: i + 1, total: data.installments } : undefined,
    };

    addDocumentNonBlocking(transactionsCol, newTransaction);
  }
  
  // Verifica o orçamento para despesas
  if (data.type === 'expense') {
      const budgetValue = await getBudgetForCategory(userId, data.category);
      if (budgetValue > 0) {
          const result = await checkBudgetAndAlert({
              userId,
              transactionValue: data.value,
              transactionCategory: data.category,
              budgetValue,
          });

          if (result.shouldAlert) {
            // Em uma aplicação real, você poderia enviar um e-mail ou notificação push.
            // Por agora, retornamos a mensagem de alerta.
            console.warn("ALERTA DE ORÇAMENTO:", result.alertMessage);
            revalidatePath("/");
            return { message: `Transação adicionada. ${result.alertMessage}` };
          }
      }
  }

  revalidatePath("/");
  revalidatePath("/history");
  return { message: `Transação ${data.installments > 1 ? 'parcelada ' : ''}adicionada com sucesso!` };
}


const accountSchema = z.object({
  name: z.string().min(1, "Nome da conta é obrigatório."),
  type: z.enum(['ContaCorrente', 'CartaoCredito', 'Investimento', 'Outro']),
  initialBalance: z.number().default(0),
  limit: z.number().optional(),
});

export type AccountFormState = {
    message: string;
    errors?: { [key: string]: string[] | undefined; };
};

export async function saveAccount(userId: string, accountId: string | null | undefined, prevState: AccountFormState, formData: FormData): Promise<AccountFormState> {
    if (!userId) {
        return { message: "Usuário não autenticado.", errors: { auth: ["Usuário não autenticado"] } };
    }

    const rawData = {
        name: formData.get("name"),
        type: formData.get("type"),
        initialBalance: Number(String(formData.get("initialBalance")).replace(",", ".")) || 0,
        limit: formData.get("limit") ? Number(String(formData.get("limit")).replace(",", ".")) : undefined,
    };

    const validatedFields = accountSchema.safeParse(rawData);

    if (!validatedFields.success) {
        return {
            message: "Erro de validação.",
            errors: validatedFields.error.flatten().fieldErrors,
        };
    }
    
    const { data } = validatedFields;
    const db = getserverFirestore();
    const id = accountId || doc(collection(db, '_')).id; // generate id client-side if new
    const accountRef = doc(db, `users/${userId}/accounts`, id);

    const accountData = {
        id,
        userId,
        name: data.name,
        type: data.type,
        ...(accountId ? {} : { balance: data.initialBalance }), // Only set initial balance on create
        ...(data.type === 'CartaoCredito' && data.limit ? { limit: data.limit } : {}),
    };
    
    setDocumentNonBlocking(accountRef, accountData, { merge: true });

    revalidatePath("/accounts");
    revalidatePath("/");
    
    return { message: `Conta ${accountId ? 'atualizada' : 'criada'} com sucesso!` };
}

export async function deleteAccount(userId: string, accountId: string) {
    if (!userId) {
      console.error("User not authenticated");
      return;
    }
    const db = getserverFirestore();
    const accountRef = doc(db, `users/${userId}/accounts`, accountId);
    deleteDocumentNonBlocking(accountRef);
    revalidatePath("/accounts");
    revalidatePath("/");
}

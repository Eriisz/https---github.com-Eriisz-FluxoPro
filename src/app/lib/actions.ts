
"use server";

import { revalidatePath } from "next/cache";
import { z } from "zod";
import { addMonths, format } from "date-fns";
import { checkBudgetAndAlert } from "@/ai/flows/budgeting-alerts";
import { collection, getDocs, query, where, addDoc } from 'firebase/firestore';
import { getserverFirestore } from "@/lib/server/firebase";


async function getBudgetForCategory(userId: string, categoryId: string, month: string): Promise<number> {
    const db = getserverFirestore();
    const budgetsCol = collection(db, `users/${userId}/budgets`);
    const q = query(budgetsCol, where("categoryId", "==", categoryId), where("month", "==", month));
    const querySnapshot = await getDocs(q);
    if (!querySnapshot.empty) {
        // Assuming one budget per category for simplicity
        return querySnapshot.docs[0].data().limit;
    }
    return 0;
}

const transactionSchema = z.object({
  description: z.string().min(1, "Descrição é obrigatória."),
  value: z.number().min(0.01, "Valor deve ser maior que zero."),
  date: z.date(),
  account: z.string().min(1, "Conta é obrigatória."),
  category: z.string().min(1, "Categoria é obrigatória."),
  type: z.enum(["income", "expense"]),
  installments: z.number().min(1).max(120).default(1),
});

export type TransactionFormState = {
  message: string;
  errors?: {
    [key: string]: string[] | undefined;
  };
};

export async function addTransaction(
  userId: string,
  prevState: TransactionFormState,
  formData: FormData
): Promise<TransactionFormState> {

  if (!userId) {
    return {
        message: "Usuário não autenticado.",
        errors: { auth: ["Usuário não autenticado"] }
    }
  }
  const rawData = {
    description: formData.get("description"),
    value: Number(String(formData.get("value")).replace(",", ".")),
    date: new Date(formData.get("date") as string),
    account: formData.get("account"),
    category: formData.get("category"),
    type: formData.get("type"),
    installments: Number(formData.get("installments") || 1),
  };
  
  const validatedFields = transactionSchema.safeParse(rawData);
  
  if (!validatedFields.success) {
    console.error(validatedFields.error.flatten().fieldErrors);
    return {
      message: "Erro de validação. Verifique os campos.",
      errors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { data } = validatedFields;
  const groupId = data.installments > 1 ? crypto.randomUUID() : undefined;
  const db = getserverFirestore();
  const transactionsCol = collection(db, `users/${userId}/transactions`);

  // Find category ID from name
  const categoriesCol = collection(db, `users/${userId}/categories`);
  const catQuery = query(categoriesCol, where("name", "==", data.category));
  const catSnapshot = await getDocs(catQuery);
  const categoryId = catSnapshot.empty ? null : catSnapshot.docs[0].id;


  for (let i = 0; i < data.installments; i++) {
    const transactionDate = addMonths(data.date, i);
    const transactionValue = data.type === 'expense' ? -data.value : data.value;

    const newTransaction = {
      // id will be auto-generated by Firestore
      userId,
      description: data.description,
      value: transactionValue,
      date: transactionDate.toISOString(),
      account: data.account,
      category: data.category, // Storing name for display
      categoryId: categoryId, // Storing ID for reference
      type: data.type,
      groupId,
      installments: data.installments > 1 ? { current: i + 1, total: data.installments } : undefined,
    };
    try {
        await addDoc(transactionsCol, newTransaction);
    } catch(e: any) {
        return { message: `Erro ao adicionar transação: ${e.message}`, errors: { db: [e.message] } };
    }
  }
  
  // Verifica o orçamento para despesas
  if (data.type === 'expense' && categoryId) {
      const monthStr = format(data.date, 'yyyy-MM');
      const budgetValue = await getBudgetForCategory(userId, categoryId, monthStr);
      if (budgetValue > 0) {
          const result = await checkBudgetAndAlert({
              userId,
              transactionValue: data.value,
              transactionCategory: data.category,
              budgetValue,
          });

          if (result.shouldAlert) {
            // Em uma aplicação real, você poderia enviar um e-mail ou notificação push.
            // Por agora, retornamos a mensagem de alerta.
            console.warn("ALERTA DE ORÇAMENTO:", result.alertMessage);
            revalidatePath("/");
            return { message: `Transação adicionada. ${result.alertMessage}` };
          }
      }
  }

  revalidatePath("/");
  revalidatePath("/history");
  return { message: `Transação ${data.installments > 1 ? 'parcelada ' : ''}adicionada com sucesso!` };
}
